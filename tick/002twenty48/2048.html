<!DOCTYPE html>
<html><head><title>2048 - use arrow keys</title><style>
html, body {
  margin:0;
}
#canvas{
  width:600px;
  height:600px;
  background: #eee;
  position:absolute;
  top:50%;
  left:50%;
  margin:-300px 0 0 -300px;
  border-radius:3px;
  border:2px solid #eee;
}
</style></head><body><canvas id="canvas"></canvas></body><script>
const canvasEl = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const cssCanvasPixelWidth = parseInt(window.getComputedStyle(canvasEl).getPropertyValue('width').slice(0,-2));
const cssCanvasPixelHeight = parseInt(window.getComputedStyle(canvasEl).getPropertyValue('height').slice(0,-2));
if(cssCanvasPixelWidth && cssCanvasPixelHeight) {
  canvasEl.width = cssCanvasPixelWidth;
  canvasEl.height = cssCanvasPixelHeight;
}

const gameDim = 4;
const gameSize = gameDim * gameDim;
const boxMargin = 2 * parseInt(window.getComputedStyle(canvasEl).getPropertyValue('border-width').slice(0,-2));
const boxWidth = canvasEl.width / gameDim;
const boxHeight = canvasEl.height / gameDim;
const spawnCount = 2;
const winCondition = 2048;
const fps = 50;
const transitionTicks = 10;
const millisecs = 1000/fps;
const isAnimationEnabled = true;

var gameInterval;
var gameIterator = 0;
var isEnded = false;
var gameState = [ 
  0, 0, 0, 0,
  0, 0, 0, 0,
  0, 0, 0, 0,
  0, 0, 0, 0 
]; // aka zeros(16)
var oldState;
var animateState;

function setupGame() {
  // repopulate();
  // @todo remove after testing
  gameState[1] = gameState[2] /*= gameState[4]*/ = 2;
  gameState[3] = 4;
  // ---------

  oldState = gameState.slice();
}

function isPlaying() {
  return !isEnded && !isTransitioning(); 
}

function isTransitioning() {
  return isAnimationEnabled && gameIterator < 0;
}

function drawBox(ctx,xPos,yPos,boxWidth,boxHeight,val) {
  let fillColor = val ? "#f93" : "#aaa";
  roundRect(ctx, xPos+boxMargin,yPos+boxMargin,boxWidth-boxMargin*2,boxHeight-boxMargin*2, fillColor);

  if(val) {
    ctx.font = "bold " + ( 90 - val.toString().length * 10 ) + "px Arial";
    ctx.fillStyle = "#333";
    ctx.textAlign = "center";
    ctx.fillText(val,xPos+75,yPos+105);
  }
}

function updateFrame() {
  ctx.fillStyle="#eee";
  ctx.fillRect(0,0,canvasEl.width,canvasEl.height);
  for(let i=0;i<gameSize;i++) {
    let xPos = boxWidth * ( i % gameDim );
    let yPos = boxHeight * ( Math.floor( i / gameDim ) % gameDim );
    drawBox(ctx,xPos,yPos,boxWidth,boxHeight,gameState[i] * !isTransitioning());
  }

  //if transitioning, draw transition boxes
  if( isTransitioning() ) {
    for(let i=0;i<gameSize;i++) {
      let cur = gameState[i];
      if(cur) {
        let xPos = boxWidth * ( i % gameDim );
        let yPos = boxHeight * ( Math.floor( i / gameDim ) % gameDim );
        drawBox(ctx,xPos+Math.abs(gameIterator)*4,yPos,boxWidth,boxHeight,gameState[i],cur);
      }
    }
  }

  gameIterator++;
}

window.onkeydown = function(e) {
  if( !isPlaying() ) {
    return;
  }
  var key = e.which;
  var left = 37;
  var up = 38;
  var right = 39;
  var down = 40;
  var space = 32;
  var w = 87;
  var a = 65;
  var s = 83;
  var d = 68;

  if( key===up || key===w ) {
    moveUp()
  } else if( key===down || key===s ) {
    moveDown();
  } else if( key===left || key===a ) {
    moveLeft();
  } else if( key===right || key===d ) {
    moveRight();
  } else if( key===space ) {
    undo();
  }
};

(function gameLoop() {
  document.addEventListener('DOMContentLoaded', x => {
    setupGame();
    gameInterval = setInterval( updateFrame, millisecs );
  }, false);
})();

function undo() {
  gameState = oldState.slice();
}

function roundRect(ctx, x, y, width, height, fillStyle, radius) { // Thanks Juan Mendes stackO/1255512
  if (typeof radius === 'undefined') {
    radius = 5;
  }
  if (typeof radius === 'number') {
    radius = {tl: radius, tr: radius, br: radius, bl: radius};
  } else {
    var defaultRadius = {tl: 0, tr: 0, br: 0, bl: 0};
    for (var side in defaultRadius) {
      radius[side] = radius[side] || defaultRadius[side];
    }
  }
  ctx.beginPath();
  ctx.moveTo(x + radius.tl, y);
  ctx.lineTo(x + width - radius.tr, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
  ctx.lineTo(x + width, y + height - radius.br);
  ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
  ctx.lineTo(x + radius.bl, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
  ctx.lineTo(x, y + radius.tl);
  ctx.quadraticCurveTo(x, y, x + radius.tl, y);
  ctx.closePath();

  ctx.fillStyle = fillStyle;
  ctx.fill();
}

function moveUp() {
  mapIndexAndStack( (i,j,k) => { return i + k * gameDim } );
  repopulate();
}
function moveDown() {
  mapIndexAndStack( (i,j,k) => { return i + j * gameDim } );
  repopulate();
}
function moveLeft() {
  mapIndexAndStack( (i,j,k) => { return k + i * gameDim } );
  repopulate();
}
function moveRight() {
  mapIndexAndStack( (i,j,k) => { return j + i * gameDim } );
  repopulate();
}

function repopulate() {
  let zeroIndex = new Array();
  for(i in gameState) {
    if(!gameState[i]) {
      zeroIndex.push(i);
    } else if( gameState[i] >= winCondition ) {
      endGame('You won!');
    }
  }

  if(zeroIndex.length<spawnCount) {
    endGame('Game over!');
  }

  for(let i=0;i<spawnCount;i++) {
    let randIndex = Math.floor(Math.random() * zeroIndex.length);
    let val = gameState[zeroIndex[randIndex]];
    val = val === 0 ? 2 : val * 2;
    gameState[zeroIndex[randIndex]] = val;
  }
}

function endGame(status) {
  isEnded=true;
  clearInterval(gameInterval);

  let fillStyle="#e00";
  if(status==='You won!') {
    fillStyle="#0e0"
  }
  roundRect(ctx, 0, 0, canvasEl.width, canvasEl.height, fillStyle);

  ctx.font = "bold 90px Arial";
  ctx.fillStyle = "#fff";
  ctx.textAlign = "center";
  ctx.fillText(status, canvasEl.width/2, canvasEl.height/2);
}

/* 
 * Expected: lambda(i, j, jInverse)
 * for each i iteration, it does a full shiftCombine
 */
function mapIndexAndStack(lambda) {
  oldState = gameState.slice();
  animateState = zeros(gameSize);

  console.log('---');
  for(let i=0;i<gameDim;i++) {
    let indexMap = new Array();
    for(let j=0;j<gameDim;j++) {
      let jInv = gameDim - j - 1;
      indexMap.push( lambda( i, j, jInv ) );
    }
    shiftCombine(gameState, indexMap);
  }
  gameIterator = -transitionTicks; //flag for transition
}

/*
 * The core game function. Given a row or column defined by indexMap, 
 * move, combine and move all elements to next state transition
 */
function shiftCombine(arr, indexMap) {
  if(indexMap.length != gameDim ) {
    throw 'Bad shiftCombine() call. IndexMap size must match gameDim';
  }

  let row = indexMap.slice().map( i => arr[i] );
  let animateRow = getTransitionMap( row );

  let ret=squashed = squash( row ); //here is the guaranted-to-work stateShift function, but it doesnt produce a transition map which is kinda what we want
  //let padAmount = gameDim - squashed.length;
  //let ret = leftPad( squashed, padAmount ); //PUT THIS IN FUNC

  for( i in ret ) {
    let x = indexMap[i];
    arr[x] = ret[i];
    animateState[x] = animateRow[i];
  }
}

function getTransitionMap( row, showLogging=false ) {
  let zeroMap = sequence(gameDim);

  let cur = row[0];
  for(let i=j=0,next=nextNonZeroth( row, i );next!=null && i<gameDim;i++) {
    // console.log('i,next=',i,next)
    cur = row[zeroMap[j]];
    j = next.index;
    //console.log(i,j,cur)
    
    // move if empty
    if(!cur) {
      //console.log('move');
      zeroMap[next.index] = i;
      next = nextNonZeroth( row, j );
      if (next==null) break;
      cur = row[j];
      j = next.index;
    } //else { console.log('noMove i,j,cur',i,j,cur)}

    if (cur == next.value) { //squash
      //console.log('sqaush');
      zeroMap[next.index] = i;
      j = next.index;
      next=nextNonZeroth(row,j);
    }

  }

  //zeroMap = zeroMap.reverse(); //saves us having to backwards count

  let result = zeros(gameDim);
  for(let i=0;i<gameDim;i++) {
    let nth = zeroMap[i];
    result[nth]+=row[i]; 
    //console.log('n rn',nth,row[nth])
    //console.log(result.join('-'));
  }

  if( showLogging ) {
    console.log(row.join(),'--(',zeroMap.join(),')--',result.join());
    return;
  }

  //squash is gold standard, be like squash()
  return result.reverse();

  // ZERO MAP IS NOW TRANSITION / ANIMATION MAP!!!!!!!!!!!
  // rESULT IS THE VALUES< NOT THE INDICES

  //return result.map(x=>{return gameDim-1-x});
  //we want to translate the local [0,4) map into the stateSpace map
  // formerly let ret = zeroMap.map(x => {return indexMap[gameDim-x]} );

  //console.log(indexMap, zeroMap, result);
  //let ret = zeroMap.map(x => {return indexMap[x]} );

  // if(next!=null) {
  //   for(let i=0;i<gameDim;i++) {
  //     if(row[i]===row[j]) {
  //       //squash
  //     }
  //   }
  // }
  // for( let i=j=0;i<gameDim && j < gameDim;i++) { //only increment j when we write 

  //   //zeroMap[j] = i;

  //   let cur = row[j];
  //   let nextNonZero = zucc( row, j );
  //   if( !cur && nextNonZero==null) break;

  //   //moveStep //move if current empty, next not
  //   zeroMap[j] = **

  //   if( ... ) {
  //     //SquashStep //squash if current equals next
  //   } 

  //   //single increment if both exist, but are not equal

  //   //j++;
  // }

  // console.log(zeroMap);
  // let ret = zeroMap.map(x => {return indexMap[gameDim-x]} );
  // return ret;
}

function nextNonZeroth( row, currentIndex ) { //return the next non-zero element
  for(let i=currentIndex+1;i<row.length;i++) {
    if(row[i]) {
      return {
        index: i,
        value: row[i]
      };
    }
  }
  return null;
}

// function getAnimationMap( row, indexMap ) {
//   let zeroMap = sequence(gameDim);

//   for(let i=j=gameDim-1;i>=0 && j>=0;i--,j--) {
//     //let cur = row[j];
//     let prev = getNextPrevNonZeroth( row, j );
//     if(!row[j]) continue;
//     if(prev===null) break;

//     zeroMap[j] = i;

//     console.log(prev);
//     if(prev!=null && prev.value == row[i]) {
//       console.log('JJJJJ',j);
//       j = prev.index;
//       console.log('assigning index ', prev.index );
//       zeroMap[j] = i;
//     }
//   }

//   // console.log('zeroMap: ',zeroMap);
//   // console.log('animationMap: ',ret);
//   let ret = zeroMap.map(x => {return indexMap[x]} );
//   return ret;
// }

// function getNextPrevNonZeroth( row, currentIndex ) {
//   for(let i=currentIndex-1;i>=0;i--) {
//     if(row[i]) {
//       // console.log('currentIndex =',currentIndex,'row[',i,'] = ', row[i]);
//       return {
//         index: currentIndex - i,
//         value: row[i]
//       };
//     }
//   }
//   // console.log('zerothing null');
//   return null;
// }

function zeros(len) {
  if(typeof len === 'undefined' || len < 1 ) {
    return [];
  }
  return new Array(len+1).join('0').split('').map(parseFloat);
}

// Generates a sequence from 0..n-1
function sequence(n) {
  return Array.apply(null, {length: n}).map(Number.call, Number);
}

//remove all zero & falsy values from an array
function compress(arr) {
  let ret = new Array();
  for( i in arr ) {
    if( arr[i] ) {
      ret.push(arr[i]);
    }
  }
  return ret;
}

// Compress, combine all adjacent like pairs (from right to left), compress, return
function squash(row) {
  let unsquashed = compress(row);
  for(let i=unsquashed.length-1;i>0;i--){
    let cur = unsquashed[i];
    let prev= unsquashed[i-1];

    if(cur!=0 && cur===prev){ 
      unsquashed[i] = cur * 2;
      unsquashed[i-1] = 0;
    }
  }
  let squashed = compress(unsquashed);
  return leftPad(squashed, gameDim-squashed.length);
}

function leftPad( arr, amount ) {
  if(!amount || amount<1) {
    return arr;
  }
  return zeros( amount ).concat( arr );
}

(function test() {
  //getTransitionMap( [2,0,4,8], null);
  //getTransitionMap( [0,2,0,2], null);
  //getTransitionMap( [0,2,2,4], null);
  //getTransitionMap( [2,0,0,0], null);
  //getTransitionMap( [0,0,0,2], null);

  console.log('filthyboi test');

  let passCount=failCount=0;

  for(let i=0;i<256;i++) {
    //all inputs assume a moveright

    let a = Math.floor(i/64)%4;
    let b = Math.floor(i/16)%4;
    let c = Math.floor(i/4)%4;
    let d = i%4;
    let testInput = [a,b,c,d].map(x=>{return x==0?0:Math.pow(2,x)});
    //console.log(testInput);

    let squashOutput = squash(testInput);
    let transOutput = getTransitionMap(testInput);

    if( arraysEqual(squashOutput,transOutput) ) {
      //console.log('input PASSED ',testInput.join('-'),' :: ',squashOutput.join('-'),'===',transOutput.join('-'));
      passCount++;
    } else {
      console.error('input failed',testInput.join('-'),' :: s/t =',squashOutput.join('-'),'!==',transOutput.join('-'));
      getTransitionMap(testInput, true);
      failCount++;
    }
  }
  console.log('-----')
  console.log('passed',passCount);
  console.log('failed',failCount);
})()


//@todo test function, remove
function arraysEqual(a, b) {
  if (a === b) return true;
  if (a == null || b == null) return false;
  if (a.length != b.length) return false;

  // If you don't care about the order of the elements inside
  // the array, you should sort both arrays here.

  for (var i = 0; i < a.length; ++i) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}

</script>
</html>
