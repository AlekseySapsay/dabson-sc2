<!DOCTYPE html>
<html><head><style>
html, body {
  margin:0;
}
#canvas{
  width:600px;
  height:600px;
  background: #eee;
  position:absolute;
  top:50%;
  left:50%;
  margin:-300px 0 0 -300px;
  border-radius:3px;
  border:2px solid #eee;
}
</style></head><body><canvas id="canvas"></canvas></body><script>
const canvasEl = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const cssCanvasPixelWidth = parseInt(window.getComputedStyle(canvasEl).getPropertyValue('width').slice(0,-2));
const cssCanvasPixelHeight = parseInt(window.getComputedStyle(canvasEl).getPropertyValue('height').slice(0,-2));
if(cssCanvasPixelWidth && cssCanvasPixelHeight) {
  canvasEl.width = cssCanvasPixelWidth;
  canvasEl.height = cssCanvasPixelHeight;
}

const gameDim = 4;
const boxMargin = 4; //should be twice the canvas border width (border subsidises outer margin)
const boxWidth = canvasEl.width / gameDim;
const boxHeight = canvasEl.height / gameDim;

var gameIterator = 0;
var gameState = [ 
  0, 0, 0, 0,
  0, 0, 0, 0,
  0, 0, 0, 0,
  0, 0, 0, 0 ];

function setupGame() {
  //@todo randomise this
  gameState[0] = gameState[4] = gameState[8] = gameState[12] = gameState[15] = 2;
}

function drawBox(ctx,xPos,yPos,boxWidth,boxHeight,val) {
  let fillColor = val ? "#f93" : "#aaa";
  roundRect(ctx, xPos+boxMargin,yPos+boxMargin,boxWidth-boxMargin*2,boxHeight-boxMargin*2, fillColor);

  if(val) {
    ctx.font = "bold " + ( 90 - val.toString().length * 10 ) + "px Arial";
    ctx.fillStyle = "#333";
    ctx.textAlign = "center";
    ctx.fillText(val,xPos+75,yPos+105);
  }
}

function updateFrame() {
  for(let i=0;i<gameDim*gameDim;i++) {
    let xPos = boxWidth * ( i % gameDim );
    let yPos = boxHeight * ( Math.floor( i / gameDim ) % gameDim );
    drawBox(ctx,xPos,yPos,boxWidth,boxHeight,gameState[i]);
  }
  gameIterator++;
}

window.onkeydown = function(e) {
  var key = e.which;
  var left = 37;
  var up = 38;
  var right = 39;
  var down = 40;
  var space = 32;
  var w = 87;
  var a = 65;
  var s = 83;
  var d = 68;

  if( key===up || key===w ) {
    moveUp()
  } else if( key===down || key===s ) {
    moveDown();
  } else if( key===left || key===a ) {
    moveLeft();
  } else if( key===right || key===d ) {
    moveRight();
  } 
};

(function gameLoop() {
  let fps = 50;
  let millisecs = 1000/fps;
  document.addEventListener('DOMContentLoaded', x => {
    setupGame();
    setInterval( updateFrame, millisecs );
  }, false);
})();


function roundRect(ctx, x, y, width, height, fillStyle, radius) { // Thanks Juan Mendes stackO/1255512
  if (typeof radius === 'undefined') {
    radius = 5;
  }
  if (typeof radius === 'number') {
    radius = {tl: radius, tr: radius, br: radius, bl: radius};
  } else {
    var defaultRadius = {tl: 0, tr: 0, br: 0, bl: 0};
    for (var side in defaultRadius) {
      radius[side] = radius[side] || defaultRadius[side];
    }
  }
  ctx.beginPath();
  ctx.moveTo(x + radius.tl, y);
  ctx.lineTo(x + width - radius.tr, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
  ctx.lineTo(x + width, y + height - radius.br);
  ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
  ctx.lineTo(x + radius.bl, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
  ctx.lineTo(x, y + radius.tl);
  ctx.quadraticCurveTo(x, y, x + radius.tl, y);
  ctx.closePath();

  ctx.fillStyle = fillStyle;
  ctx.fill();
}

function moveUp() {
  // shiftCombine(gameState, 12, 8, 4, 0);
  // shiftCombine(gameState, 12, 8, 4, 0);
  // shiftCombine(gameState, 12, 8, 4, 0);
  // shiftCombine(gameState, 12, 8, 4, 0);

  // for(let i=0;i<gameDim;i++) {
  //   let indexMap = new Array();
  //   for(let j=0;j<gameDim;j++) {
  //     let jInv = gameDim - j - 1;
  //     indexMap.push( i + jInv * gameDim )
  //   }
  //   shiftCombine(gameState, indexMap);
  // }

  // i + jInv * gameDim

  mapIndexAndStack( (i,ii,j,jj) => { return i + jj * gameDim } );
}
function moveDown() {
  mapIndexAndStack( (i,ii,j,jj) => { return  } );
}

function moveLeft() {
  mapIndexAndStack( (i,ii,j,jj) => { return  } );
}
function moveRight() {

  // 0,1,2,4 //moves from leftmost index to rightmost index  
  // shiftCombine(gameState, [0,1,2,3]);
  // shiftCombine(gameState, [4,5,6,7]);
  // shiftCombine(gameState, [8,9,10,11]);
  shiftCombine(gameState, [12,13,14,15]);

  //mapIndexAndStack( (i,ii,j,jj) => { return j + i * gameDim } );

}

/* 
 * Expected: lambda(i, invI, j, invJ)
 * for each i iteration, it does a full shiftCombine
 */
function mapIndexAndStack(lambda) {
  for(let i=0;i<gameDim;i++) {
    let iInv = gameDim - i - 1;
    let indexMap = new Array();
    for(let j=0;j<gameDim;j++) {
      let jInv = gameDim - j - 1;
      indexMap.push( lambda( i, iInv, j, jInv ) );
    }
    shiftCombine(gameState, indexMap);
  }
}

function shiftCombine(arr, indexMap) {
  if(indexMap.length != gameDim ) {
    throw 'Bad shiftCombine() call. IndexMap size must match gameDim';
  }
  let ret = new Array();
  for(let i=0;i<gameDim;i++) {
    let cur = arr[indexMap[i]];
    let next = ( i === ( gameDim - 1 ) ) ? 0 : arr[indexMap[i+1]];
    if(cur===0) {
      continue;
    } else if(cur===next) {
      ret.push(cur*2);
      i++;
    } else {
      ret.push(cur);
    }
  }
  ret = ret.concat( zeros( gameDim - ret.length ) );
  for( i in ret ) {
    arr[indexMap[i]] = ret[ gameDim-1-i ];
  }
}

function zeros(len) {
  if(typeof len === 'undefined' || len < 1 ) {
    return [];
  }
  return new Array(len+1).join('0').split('').map(parseFloat);
}
</script>
</html>
